package types

import (
	"time"
	"errors"
	"github.com/libp2p/go-libp2p-crypto"
	"encoding/json"
	"github.com/libp2p/go-libp2p-peer"
	"fmt"
	"github.com/tinychain/tinychain/common"
)

var (
	errSignInvalid = errors.New("signature mismatch with public key")
)

// FileDesc describes the meta info of data to be stored in IPFS.
type FileDesc struct {
	Cid       string        `json:"cid"`       // content hash of data generated by IPFS.
	PubKey    []byte        `json:"pubkey"`    // public key of data owner.
	Signature []byte        `json:"signature"` // signature generated by data owner with private key.
	Peers     int           `json:"peers"`     // the expected amount of peers to store data.
	Duration  time.Duration `json:"timeout"`   // the storing length of data.
}

func (fd *FileDesc) verify() error {
	pubkey, err := crypto.UnmarshalPublicKey(fd.PubKey)
	if err != nil {
		return err
	}
	ok, err := pubkey.Verify([]byte(fd.Cid), fd.Signature)
	if err != nil {
		return err
	}
	if !ok {
		return errSignInvalid
	}
	return nil
}

func (fd *FileDesc) Serialize() ([]byte, error) {
	return json.Marshal(fd)
}

func (fd *FileDesc) Deserialize(d []byte) error {
	return json.Unmarshal(d, fd)
}

// CopyMessage holds the `FileDesc` and multicast other peers to request storing data by given cid.
type CopyMessage struct {
	FileDesc *FileDesc   `json:"file_desc"`
	ProofId  string      `json:"proof_id"`
	Peers    int         `json:"peers"` // the count of peers need to be multicast at a certain round.
	SignList []*SignMeta `json:"signs"`
	SrcPeer  peer.ID     `json:"src_peer"`
}

type SignMeta struct {
	PubKey    []byte `json:"pub_key"`
	Signature []byte `json:"signature"`
}

// Verify verifies the file description and signature in SignList.
func (copy *CopyMessage) Verify() error {
	// Verify file description
	if err := copy.FileDesc.verify(); err != nil {
		return err
	}
	// Verify signature list
	for _, sm := range copy.SignList {
		pubkey, err := crypto.UnmarshalPublicKey(sm.PubKey)
		if err != nil {
			return err
		}
		fd, err := copy.FileDesc.Serialize()
		if err != nil {
			return err
		}
		match, err := pubkey.Verify(fd, sm.Signature)
		if err != nil {
			return err
		}
		if !match {
			return fmt.Errorf("signature %s mismatch with public key %s", common.Bytes2Hex(sm.Signature), common.Bytes2Hex(sm.PubKey))
		}
	}
	return nil
}

func (copy *CopyMessage) Serialize() ([]byte, error) {
	return json.Marshal(copy)
}

func (copy *CopyMessage) Deserialize(d []byte) error {
	return json.Unmarshal(d, copy)
}
