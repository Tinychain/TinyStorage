package types

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/libp2p/go-libp2p-crypto"
	"github.com/libp2p/go-libp2p-peer"
	"github.com/tinychain/tinychain/common"
	"sync/atomic"
	"time"
)

var (
	errSignInvalid = errors.New("signature mismatch with public key")
)

// FileDesc describes the meta info of data to be stored in IPFS.
type FileDesc struct {
	h atomic.Value

	// field used for hash
	Cid      string        `json:"cid"`     // content hash of data generated by IPFS.
	Peers    int           `json:"peers"`   // the expected amount of peers to store data.
	Duration time.Duration `json:"timeout"` // the storing length of data.
	Size     int           `json:"size"`    // size of storing data

	PubKey    []byte `json:"pubkey"`    // public key of data owner.
	Signature []byte `json:"signature"` // signature generated by data owner with private key.
}

func (fd *FileDesc) verify() error {
	pubkey, err := fd.publicKey()
	if err != nil {
		return err
	}
	ok, err := pubkey.Verify(fd.hash(), fd.Signature)
	if err != nil {
		return err
	}
	if !ok {
		return errSignInvalid
	}
	return nil
}

func (fd *FileDesc) hash() []byte {
	if hash := fd.h.Load(); hash != nil {
		return hash.(common.Hash).Bytes()
	}
	data := make([]byte, 16)
	binary.BigEndian.PutUint64(data[:8], uint64(fd.Peers))
	binary.BigEndian.PutUint64(data[8:16], uint64(fd.Duration))
	hash := common.Sha256(bytes.Join([][]byte{[]byte(fd.Cid), data}, nil))
	fd.h.Store(hash)
	return hash.Bytes()
}

func (fd *FileDesc) publicKey() (crypto.PubKey, error) {
	pubkey, err := crypto.UnmarshalPublicKey(fd.PubKey)
	if err != nil {
		return nil, err
	}
	return pubkey, nil
}

func (fd *FileDesc) Serialize() ([]byte, error) {
	return json.Marshal(fd)
}

func (fd *FileDesc) Deserialize(d []byte) error {
	return json.Unmarshal(d, fd)
}

// CopyMessage holds the `FileDesc` and multicast other peers to request storing data by given cid.
type CopyMessage struct {
	FileDesc *FileDesc   `json:"file_desc"`
	ProofId  string      `json:"proof_id"`
	Peers    int         `json:"peers"` // the count of peers need to be multicast at a certain round.
	SignList []*SignMeta `json:"signs"`
	SrcPeer  peer.ID     `json:"src_peer"`
}

type SignMeta struct {
	PubKey    []byte `json:"pub_key"`
	Signature []byte `json:"signature"`
}

// Verify verifies the file description and signature in SignList.
func (copy *CopyMessage) Verify(proof *Proof) error {
	// Verify file description
	if err := copy.FileDesc.verify(); err != nil {
		return err
	}

	// Verify with proof
	if copy.FileDesc.Cid != proof.Cid {
		return fmt.Errorf("cid mismatch, %s in fileDesc, %s in proof", copy.FileDesc.Cid, proof.Cid)
	}

	if copy.FileDesc.Peers != proof.Peers {
		return fmt.Errorf("amount of storing peers mismatch, %d in fileDesc, %d in proof", copy.FileDesc.Peers, proof.Peers)
	}

	if copy.FileDesc.Duration != proof.Duration {
		return fmt.Errorf("expected storing duration mismatch, %d in fileDesc, %d in proof", copy.FileDesc.Duration, proof.Duration)
	}

	if copy.FileDesc.Size != proof.Size {
		return fmt.Errorf("data size mismatch, %d in fileDesc, %d in proof", copy.FileDesc.Size, proof.Size)
	}

	pubkey, err := copy.FileDesc.publicKey()
	if err != nil {
		return err
	}

	if match, err := pubkey.Verify([]byte(proof.ID()), proof.Signature); err != nil || !match {
		return fmt.Errorf("signature in proof cannot be verified by the public key in fileDesc")
	}

	// Verify signature list
	for _, sm := range copy.SignList {
		pubkey, err := crypto.UnmarshalPublicKey(sm.PubKey)
		if err != nil {
			return err
		}
		fd, err := copy.FileDesc.Serialize()
		if err != nil {
			return err
		}
		match, err := pubkey.Verify(fd, sm.Signature)
		if err != nil {
			return err
		}
		if !match {
			return fmt.Errorf("signature %s mismatch with public key %s", common.Bytes2Hex(sm.Signature), common.Bytes2Hex(sm.PubKey))
		}
	}
	return nil
}

// Sign signs the copy message with the node's private key and append
// meta info to sign list.
func (copy *CopyMessage) Sign(privKey crypto.PrivKey) error {
	fd, err := copy.FileDesc.Serialize()
	if err != nil {
		return err
	}
	sign, err := privKey.Sign(fd)
	pubkeyBytes, err := privKey.GetPublic().Bytes()
	if err != nil {
		return err
	}

	// Append signature meta info to sign list
	copy.SignList = append(copy.SignList, &SignMeta{pubkeyBytes, sign})
	return nil
}

func (copy *CopyMessage) Clone() *CopyMessage {
	c := *copy
	c.SignList = nil
	for _, signmeta := range copy.SignList {
		c.SignList = append(c.SignList, signmeta)
	}
	return &c
}

func (copy *CopyMessage) Serialize() ([]byte, error) {
	return json.Marshal(copy)
}

func (copy *CopyMessage) Deserialize(d []byte) error {
	return json.Unmarshal(d, copy)
}
